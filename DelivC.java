import java.io.*;
import java.util.ArrayList; // Imported Library DelivC
import java.util.Collections;
import java.util.Comparator;
import java.util.PriorityQueue; // Imported Library DelivC

public class DelivC{

	private File inputFile;
	private File outputFile;
	private PrintWriter output;
	private Graph graph;

	//Constructor - DO NOT MODIFY
	public DelivC(File in, Graph gr) {
		inputFile = in;
		graph = gr;

		// Set up for writing to a file
		try {
			// Use input file name to create output file in the same location
			String inputFileName = inputFile.toString();
			String outputFileName = inputFileName.substring(0, inputFileName.length() - 4).concat("_out.txt");
			outputFile = new File(outputFileName);

			// A Printwriter is an object that can write to a file
			output = new PrintWriter(outputFile);
		} catch (Exception x) {
			System.err.format("Exception: %s%n", x);
			System.exit(0);
		}
		
		// Calls the method that will do the work of deliverable C
		runDelivC();

		output.flush();
	}

	//*********************************************************************************
	//               This is where your work starts
	
	private void runDelivC() {
		
		this.MST_Prim();
		
		// Display the data generated by Prim's
		System.out.println("The minimum spanning tree has a total cost of " + this.graph.getMstCost() + " includes the following edges:");
		for (Node n : this.graph.getNodeList()) {
			// Skip the start node as it has no predecessor.
			if (!n.getValue().equalsIgnoreCase("S")) {
				System.out.println(n.getAbbrev() + "-" + n.getPredecessor().getAbbrev());
			}
		}
	}
	
	public void MST_Prim() {
		
		// Reference the graphs node list with a variable for easier use.
		ArrayList<Node> graphNodeList = this.graph.getNodeList();
		
		/* Place the start node in front using the comparator defined below.
		 * This is done here so we can access the start node easier and set
		 * its key to 0. The rest will be sorted alphabetically but that
		 * isn't too valuable here.
		 */
		Collections.sort(graphNodeList, new StartNodeComparer());
		
		// Initialize the graphs nodes.
		for (Node u : graphNodeList) {
			u.setKey(Integer.MAX_VALUE);
			u.setPredecessor(null);
		}
		
		// Set the start nodes key to 0.
		graphNodeList.get(0).setKey(0);
		
		/* Place the now initialized nodes of the graph into a priority queue
		 * ordered by the comparator defined below. The start node will be on
		 * top due to it having its key set to 0 while the rest are set to MAX_VALUE.
		 */
		PriorityQueue<Node> Q = new PriorityQueue<Node>(graphNodeList.size(), new NodeKeyComparer());
		Q.addAll(graphNodeList);
		
		// Loop over the queue until it is empty.
		while (!Q.isEmpty()) {
			
			// Grab the smallest node from the queue.
			Node u = Q.poll();
			// Calculate the MST's new cost and update it.
			int newMSTCost = this.graph.getMstCost() + u.getKey();
			this.graph.setMstCost(newMSTCost);
			
			/* Loop over the current nodes outgoing edges.
			 * Extract the head from each edge and update its
			 * values if necessary. Remove and re-add each node
			 * from the queue, if updated, so the queue will
			 * stay up to date.
			 */
			for (Edge e : u.getOutgoingEdges()) {
				Node v = e.getHead();
				int newKey = e.getDistance();
				if (Q.contains(v) && newKey < v.getKey()) {
						v.setPredecessor(u);
						v.setKey(newKey);
						Q.remove(v);
						Q.add(v);
					}
				}
			}
		}
	
	class StartNodeComparer implements Comparator<Node>{

		@Override
		public int compare(Node node1, Node node2) {
			
			if (node1.getValue().equalsIgnoreCase("S")) {
				return -1;
			}
			
			else if (node2.getValue().equalsIgnoreCase("S")) {
				return 1;
			}
			
			else if (node1.getAbbrev().compareToIgnoreCase(node2.getAbbrev()) > 0) {
				return 1;
			}
			
			else if (node1.getAbbrev().compareToIgnoreCase(node2.getAbbrev()) < 0) {
				return -1;
			}
			
			else {
				return 0;
			}
		}
	}
	
	class NodeKeyComparer implements Comparator<Node>{

		@Override
		public int compare(Node node1, Node node2) {
			if (node1.getKey() > node2.getKey()) {
				return 1;
			}
			else if (node1.getKey() < node2.getKey()) {
				return -1;
			}
			if (node1.getKey() == node2.getKey()) {
				if (node1.getAbbrev().compareToIgnoreCase(node2.getAbbrev()) > 0) {
					return 1;
				}
				else return -1;
			}
			else {
				return 0;
			}
		}	
	}
}